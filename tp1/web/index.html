<head>
<title>TP1: Coloration de l'Empire Russe</title>

<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
<link rel="stylesheet" href="style.css">

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
</script>

<script>
  const images = {
    "lowres" : [
      {"img": "00106v", "rx": -1, "ry": 9, "gx": 0, "gy": 4},
      {"img": "00757v", "rx": 5, "ry": 5, "gx": 3, "gy": 2},
      {"img": "00888v", "rx": 0, "ry": 12, "gx": 0, "gy": 6},
      {"img": "00889v", "rx": 3, "ry": 4, "gx": 2, "gy": 2},
      {"img": "00907v", "rx": 0, "ry": 6, "gx": 0, "gy": 3},
      {"img": "00911v", "rx": -1, "ry": 13, "gx": 0, "gy": 1},
      {"img": "01031v", "rx": 2, "ry": 4, "gx": 1, "gy": 1},
      {"img": "01657v", "rx": 1, "ry": 12, "gx": 0, "gy": 6},
      {"img": "01880v", "rx": 4, "ry": 14, "gx": 2, "gy": 6}
    ],
    "highres" : [
      {"img": "00001u", "rx": -7, "ry": 97, "gx": 3, "gy": 38},
      {"img": "00029u", "rx": 34, "ry": 91, "gx": 16, "gy": 39},
      {"img": "00087u", "rx": 55, "ry": 108, "gx": 38, "gy": 48},
      {"img": "00106u", "rx": -8, "ry": 93, "gx": 9, "gy": 39},
      {"img": "00128u", "rx": 38, "ry": 52, "gx": 25, "gy": 35},
      {"img": "00316u", "rx": 20, "ry": 110, "gx": 9, "gy": 30},
      {"img": "00451u", "rx": 0, "ry": 426, "gx": 0, "gy": 421},
      {"img": "00458u", "rx": 32, "ry": 87, "gx": 6, "gy": 43},
      {"img": "00737u", "rx": 14, "ry": 49, "gx": 7, "gy": 15},
      {"img": "00822u", "rx": 33, "ry": 125, "gx": 25, "gy": 57},
      {"img": "00892u", "rx": 4, "ry": 43, "gx": 2, "gy": 16},
      {"img": "01043u", "rx": 17, "ry": 11, "gx": 10, "gy": -16},
      {"img": "01047u", "rx": 33, "ry": 71, "gx": 20, "gy": 24},
      {"img": "01218u", "rx": 57, "ry": 119, "gx": 36, "gy": 59},
      {"img": "01224u", "rx": 28, "ry": 139, "gx": 22, "gy": 67},
      {"img": "01294u", "rx": 41, "ry": 137, "gx": 30, "gy": 64},
      {"img": "01787u", "rx": 36, "ry": 146, "gx": 25, "gy": 68},
      {"img": "01886u", "rx": 58, "ry": 101, "gx": 24, "gy": 49}
    ],
    "edges" : [
      {"img": "00001u", "rx": -8, "ry": 97, "gx": 2, "gy": 38},
      {"img": "00029u", "rx": 32, "ry": 91, "gx": 14, "gy": 39},
      {"img": "00087u", "rx": 56, "ry": 107, "gx": 38, "gy": 49},
      {"img": "00106u", "rx": 0, "ry": 91, "gx": 9, "gy": 38},
      {"img": "00128u", "rx": 37, "ry": 49, "gx": 26, "gy": 37},
      {"img": "00316u", "rx": 0, "ry": 0, "gx": 10, "gy": 30},
      {"img": "00451u", "rx": -36, "ry": 103, "gx": -19, "gy": 45},
      {"img": "00458u", "rx": 30, "ry": 85, "gx": 0, "gy": 41},
      {"img": "00737u", "rx": 15, "ry": 50, "gx": 7, "gy": 16},
      {"img": "00822u", "rx": 33, "ry": 125, "gx": 25, "gy": 57},
      {"img": "00892u", "rx": 0, "ry": 43, "gx": 0, "gy": 16},
      {"img": "01043u", "rx": 15, "ry": 13, "gx": 9, "gy": -14},
      {"img": "01047u", "rx": 33, "ry": 71, "gx": 20, "gy": 25},
      {"img": "01218u", "rx": 0, "ry": 128, "gx": 0, "gy": 61},
      {"img": "01224u", "rx": 28, "ry": 138, "gx": 20, "gy": 64},
      {"img": "01294u", "rx": 40, "ry": 137, "gx": 30, "gy": 63},
      {"img": "01787u", "rx": 35, "ry": 146, "gx": 24, "gy": 67},
      {"img": "01886u", "rx": 40, "ry": 107, "gx": 24, "gy": 49}
    ],
    "custom" : [
      {"img": "cats", "rx": 5, "ry": -8, "gx": -2, "gy": -20},
      {"img": "light", "rx": 0, "ry": 11, "gx": 25, "gy": 0},
      {"img": "outside", "rx": -17, "ry": -73, "gx": -31, "gy": -45},
      {"img": "candles", "rx": -17, "ry": -56, "gx": -39, "gy": -39},
      {"img": "tv", "rx": 0, "ry": 6, "gx": -22, "gy": -31},
      {"img": "plush", "rx": 0, "ry": 0, "gx": 0, "gy": 1},
      {"img": "blocks", "rx": 0, "ry": 0, "gx": 1, "gy": 1}
    ]
  }

  const changeImages = function() {
    const mode = document.getElementById("mode").checked ? "reconstructions" : "comparisons"
    
    Object.keys(images).forEach(key => {
      const scroller = document.getElementById(key)
      scroller.innerHTML = ""
      
      images[key].forEach(element => {
        const img_path = `img/${key}/${mode}/${element.img}.jpg`
        
        const img = document.createElement("img")
        img.src = img_path

        const a = document.createElement("a")
        a.appendChild(img)
        a.href = img_path

        const translation = document.createElement("p")
        translation.innerHTML = `Rouge : $\\Delta x = ${element.rx}$, $\\Delta y = ${element.ry}$ <br> Vert : $\\Delta x = ${element.gx}$, $\\Delta y = ${element.gy}$`

        const container = document.createElement("div")
        container.appendChild(a)
        container.appendChild(translation)
        container.className = "scroll-card"
        scroller.appendChild(container)
      });
    })
    MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
  }
</script>
</head>

<body onload="changeImages()">

  <h1>TP1: Coloration de l'Empire Russe</h1>

  <div class="custom-control custom-switch">
    <input type="checkbox" class="custom-control-input" id="mode" onchange="changeImages()" checked>
    <label class="custom-control-label" for="mode">Images seulement</label>
  </div>

  <h2>Approche à une seule échelle</h2> 
  <p>
    Tout d'abord, une fonction permettant de décaler les canaux rouge et vert par rapport au canal bleu a été implémentée.
    Par la suite, tous les décalages dans la plage $[-15,15]$ en $x$ et en $y$ sont essayés afin de déterminer le décalage optimal des canaux rouge et vert.
    Afin d'évaluer un décalage, la moyenne des différences au carré (MSE) entre le canal bleu et le canal évalué est calculée.
    Le décalage optimal est celui correspondant à l'erreur la plus petite. De plus, $10\%$ de chaque côté de l'image est retiré.
    Cela permet d'omettre les bord qui ne correspondent pas à l'image ou qui sont endommagés. Les images obtenues sont présentées ci-dessous.
  </p>
  <div class="scroll-container" id="lowres"></div>
  <p>
    Les résultats obtenus sont tous de bonne qualité.
    La basse résolution rend l'alignement plus simple puisque qu'un déplacement d'un pixel n'est pas négligeable.
    Il y a donc moins d'erreurs possible.
  </p>

  <h2>Approche à échelles multiples</h2> 
  <p>
    Pour les images à hautes résolution, l'approche à une échelle ne permet pas de tester assez de décalages dans un temps raisonnable.
    Les canaux originaux sont donc initialement réduits de taille par un facteur de 16 et la méthode à une échelle est appliquée sur ces images.
    Les canaux originaux sont ensuite réduits de taille par un facteur de 8 et la méthode à une échelle est appliquée.
    Cependant, au lieu de prendre une plage centrée sur zéro, le résultat obtenu avec la réduction de 16 est utilisé (le décalage est multiplié par 2 puisque l'échelle est 2 fois plus grande).
    Cette procédure est répétée en diminuant le facteur de réduction à chaque étape jusqu'à calculer le décalage sur l'échelle initiale.
    De plus la plage de recherche est dimininuée de moitié (avec un minimum de $[-2, 2]$) entre chaque étape afin d'accélérer la recherche aux résolutions plus fines.
    Les images obtenues sont présentées ci-dessous.
  </p>
  <div class="scroll-container" id="highres">
  </div>
  <p>
    La majorité des images sont de bonne qualité. Cependant, l'émir de Boukhara et l'image de la ville portuaire n'ont pas réussi à trouver un bon alignement.
    Selon moi, la cause de ces échecs vient de la différence entre les canaux. Le canal bleu est trop différent du vert et du rouge et la position optimale ne correspond pas à l'alignement cherché.
    On note aussi que $10%$ d'une image est retiré de chaques côtés, mais si plus est retiré, plus d'images sont mal alignées tel que l'image des rails.
    Le reste des images sont reconstituées avec assez de précision pour que les erreurs ne soient pas évidentes à l'oeil nu.
  </p>

  <h2>Approche par comparaison des arêtes</h2> 
  <p>
    Cette approche utilise la même méthode que l'approche à échelle multiple. Cependant, un filtre de Sobel est appliqué sur les canaux avant de calculer le MSE.
    Ainsi, ce sont les arêtes qui sont comparées plutôt que les couleurs directement. Les images obtenues sont présentées ci-dessous.
  </p>
  <div class="scroll-container" id="edges">
  </div>
  <p>
    Tout comme l'approche à échelles multiples, cette approche obtient généralementdes bons reésultats.
    La majorité n'ont qu'un ou deux pixel de différence avec la méthode précédente, ce qui n'est pas perceptible à l'oeil nu.
    Certains ont de légères différences tel que le mosieur au chapeau noir qui est un peu moins bon ou la locomotive qui est un peu meilleure.
    Finalement, d'autres ont des différences importantes comme l'émir de Boukhara et la ville portuaire qui sont bien alignés contrairement à la méthode précédente ou
    les rails et la cabine dans l'étang qui sont mal alignés cette fois.
    Cette méthode ne dépend pas de la valeur des couleurs mais plutôt de leur relation à leur voisin.
    Elle peut donc reconstituer l'émir de Boukhara puisque les arêtes sont similaires dans les canaux alors que pour la cabine, les arêtes sont plus nombreuses et moins évidentes,
    ce qui rend l'approche moins performante.
  </p>

  <h2>Je suis Gorskii!</h2> 
  <p>Les photos ci-dessous ont été prises à partir d'un Samsung Galaxy S21. L'approche à échelle multiple à été utilisée pour l'alignement en utilisant MSE pour la métrique.</p>
  <div class="scroll-container" id="custom">
  </div>
  <p>
    Les images obtenues sont généralement de bonne qualité. Cependant, certains artefacts apparaissent sur quelques photos.
    Notamment, lorsque des éléments bougent, la reconstruction ne les affichent pas correctement tel que le chat qui a tourné la tête ou la chandelle qui vacille.
    Il n'est donc pas possible d'aligner ces éléments sans désaligner le reste de l'image. <br>
    L'image de la télévision présente un phénomène similaire où l'image affichée sur la télévision est différente pour chaque canaux.
    L'image affichée résultante est donc un mélange des trois images. Cependant, la différence a aussi causé un léger désalignement sur l'image reconstituée. <br>
    Finalement, un désalignement peut aussi parfois être constaté sur les bords des images reconstituées tel que sur l'image du lit et l'image de l'extérieur.
    Cela provient probablement des mouvements lors de la prise de photo n'affectant pas les objets également selon leur distance.
  </p>

  <h3>Changement d'illumination</h3>
  <p>
    La lumière de la lampe de la deuxième photo ci-dessus peut changer de couleur.
    Ainsi, les photos prises pour la reconstitution correspondent à différentes couleurs tel que la première image ci-dessous le montre et la couleur résultante est donc blanche.
    Il est aussi possible de générer de nouvelles couleurs en l'agençant différement et même d'éteindre la lumière. Les images ci-dessous montrent différentes possibilités.
  </p>
  <div class="scroll-container">
    <div class="scroll-card"><a href="img/custom/comparisons/light.jpg"><img src="img/custom/comparisons/light.jpg" height="98%"></a></div>
    <div class="scroll-card"><a href="img/custom/comparisons/light_brr.jpg"><img src="img/custom/comparisons/light_brr.jpg" height="98%"></a></div>
    <div class="scroll-card"><a href="img/custom/comparisons/light_rrr.jpg"><img src="img/custom/comparisons/light_rrr.jpg" height="98%"></a></div>
    <div class="scroll-card"><a href="img/custom/comparisons/light_bgr.jpg"><img src="img/custom/comparisons/light_bgr.jpg" height="98%"></a></div>
    <div class="scroll-card"><a href="img/custom/comparisons/light_brb.jpg"><img src="img/custom/comparisons/light_brb.jpg" height="98%"></a></div>
    <div class="scroll-card"><a href="img/custom/comparisons/light_rgr.jpg"><img src="img/custom/comparisons/light_rgr.jpg" height="98%"></a></div>
    <div class="scroll-card"><a href="img/custom/comparisons/light_rrb.jpg"><img src="img/custom/comparisons/light_rrb.jpg" height="98%"></a></div>
    <div class="scroll-card"><a href="img/custom/comparisons/light_bgb.jpg"><img src="img/custom/comparisons/light_bgb.jpg" height="98%"></a></div>
  </div>

  <h3>Photos noires et blanches filtrées</h3>
  <p>
    Les photos de la peluche et des blocs ont été prises par une caméra noire et blanche avec un filtre placé devant l'objectif de façon similaire à Gorskii.
    Les filtres ci-dessous ont été utilisés :</p>
  <div class="scroll-card"><a href="img/other/filtres.jpg"><img src="img/other/filtres.jpg"></a></div>
  <p>
    <br>
    Les filtres ayant une absorption différente, les blancs ont été équilibrés en utilisant le museau de la peluche comme point neutre afin de compenser.
    Une comparaison avec les objets pris avec une caméra RGB est présentée ci-dessous.
    On constate que les couleurs des photos reconstituées sont plus désaturée que celle prise en couleur.
    Cela peut être expliqué par les filtres utilisés ne filtre pas aussi bien que ceux utilisés par la caméra couleur.
    Cependant, les images reconstituées sont tout de même fiables.
  </p>
    <div class="scroll-card">
      <a href="img/other/plush.jpg"><img src="img/other/plush.jpg"></a>
      <a href="img/custom/comparisons/plush.jpg"><img src="img/custom/comparisons/plush.jpg"></a>
    </div>
    <div class="scroll-card">
      <a href="img/other/blocks.jpg"><img src="img/other/blocks.jpg"></a>
      <a href="img/custom/comparisons/blocks.jpg"><img src="img/custom/comparisons/blocks.jpg"></a>
    </div>

</body>